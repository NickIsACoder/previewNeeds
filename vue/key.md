v-for中使用的key
   v-for更新已渲染的列表时，默认使用 `就地复用` 策略,如果数据项的顺序被改变
   列表数据修改的时候，会根据key值去判断某个值是否修改，如果修改则重新渲染，否则复用之前的元素。
   
例：
`<li v-for="(item) in list1" :key="item.id">
    <input type="checkbox" name="" id="">{{item.name}}
</li>`

`<li v-for="(item) in list2">
    <input type="checkbox" name="" id="">{{item.name}}
</li>`

拥有key的列表，当在中间插入一条数据时，会根据key值来判断修改的值，从而只把插入的值进行渲染，其它数据不需要重新渲染
没有key的列表，被插入数据影响到的数据都需要重新渲染

原理：
    （diff算法中，当出现跨层级的节点操作时，会先把跨级的节点新增，再把上一层级不匹配的节点删除）
    diff算法里面，判断两个节点是否为同一个节点（是否可以复用），标准是key相同且tag（标签）相同
    数据发生改变时，
        当没有key时，key都是undefined，默认相同，会采用`就地复用`策略。（virtual dom新集合中的数据与旧集合中的数据不相等，按顺序进行排列更新后，新老集合中的对应关系被改变，进而会重新渲染）
        当传了key时，virtual dom的新老集合会根据key值进行对应比较，对节点进行移动，只有新增的节点会重新渲染
        
    给元素加了key值之后，vue在做diff的时候会进行差异化对比，即通过key来判断新老集合中的节点是否相同，相同的话则只需要将新老集合中节点进行对应的移动，无需进行节点删除和创建，从而减少性能消耗
    
为什么不使用index作为key
    1、使用index做为key，实际上和不使用key效果一样
    2、index做key（就地复用），只适用于不依赖子组件状态和临时dom的渲染输出
    
key主要的作用就是为了高效地更新虚拟dom