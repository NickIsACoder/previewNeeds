<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<title></title>
	</head>
	<body>
        <!-- 
            url从输入到页面展示的过程
                1、dns解析，将域名解析成IP地址
                2、TCP连接，tcp三次握手协议
                3、发送http请求，分析url，设置请求报文
                4、服务器处理请求并返回HTTP报文（html文件）
                5、浏览器解析渲染页面
                6、断开连接：TCP四次挥手
                
                
            序列号seq：占4个字节，报文段中第一个字节的数据编号；x
            确认号ack：占4个字节，期望收到下一个字节的数据序号；x+1
            确认ACK：占1位，判断ack是否有效，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
            同步序列编码SYN：连接建立时用于同步序号
            终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
            ACK报文用来应答，SYN报文用来同步
            
            三次握手协议：
                (最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。)
                1、TCP服务器进程先建立传输控制住块TCB，时刻准备好接收客户端连接请求，服务器进入LISTEN（监听）状态
                2、TCP客户端建立传输控制块TCB，向服务器发送连接请求报文：SYN=1，seq=x；客户端进入SYN—SENT（同步已发送）状态
                3、TCP服务器接收到请求报文后，如果同意连接，则发出确认报文：SYN=1，ACK=1，seq=y，ack=x+1；服务器进入SYN-RCVD（同步收到）状态
                4、TCP客户端收到确认之后，还要向服务器给出确认，确认报文：ACK=1，seq=x+1，ack=y+1；此时TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态 
                5、TCP服务器收到客户端的确认之后，也进入ESTABLISHED（已建立连接）状态 ，此后双方开始通信
                
            
            四次挥手协议
                （客户端和服务器都是处于ESTABLISHED状态）
                1、TCP客户端发送连接释放报文：PIN=1，seq=u；客户端进入PIN-WAIT-1（终止等待1）状态
                2、TCP服务器收到连接释放报文后，发出确认报文：ACK=1，seq=v，ack=u+1；服务器进入CLOSE-WAIT（等待关闭）状态
                3、客户端收到服务器的确认请求后，进入PIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文
                4、服务器在发送完最后的数据后，向客户端发送连接释放报文：PIN=1，ack=u+1，seq=w；服务器进入LAST-ACK（最后确认）状态，等待客户端确认
                5、客户端收到服务器的连接释放报文后，必须发出确认：ACK=1，ack=w+1，seq=u+1，客户端进入TIME-WAIT(时间等待)状态，经过2*MSL（最长报文段寿命）时间后，客户端撤销相应的TCB后，才进入CLOSED状态
                6、服务器接收到客户端的确认之后，立即进入CLOSED状态，撤销TCB之后，就结束了此次TCP连接
                
                
                
            为何握手是三次，挥手要四次
                建立连接时，服务器收到客户端的SYN请求后，会把SYN和ACK放在同一个报文中发送给客户端
                而关闭连接时，服务器收到客户端的PIN报文时，服务器的数据未必已经全部发送给客户端了，可以先发送完数据，再发送PIN报文来关闭连接，所以多了一步
                
            为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
                （2MSL：一个发送和回复所需要的最大时间）
                客户端发出最后的ACK报文后，网络的不可靠可能导致ACK丢失，服务器如果没有收到ACK，会不断重复发送PIN片段。客户端在发送完ACK后会进入TIME_WAIT状态，并设置一个定时器，等待2MSL的时间，如果时间内再次收到PIN，则会重新发送ACK，并再等待2MSL的时间，如果没有再收到PIN，则表示服务器已收到ACK，客户端进入CLOSE状态，关闭TCP连接
                
            如果已经建立了连接，但是客户端突然出现故障了怎么办？
                TCP还设有一个保活计时器，服务器每收到一次客户端的请求，就会重新复位这个计时器，时长为2小时。如果2小时后还没收到客户端的任何数据，服务器就会每隔75秒发送一个探测报文段，连续发送10次后仍没反应，服务器就会认为客户端出现了故障，从而关闭TCP连接
                
        -->
        <!-- 
            浏览器存储：
                cookie：存储上限4KB，可设置过期时间
                localStroge：长期存储，体积限制为4-5M
                sessionStorage: 窗口关闭删除，体积限制为4-5M
         -->
        <!--
            浏览器便签页通信：
                1、父页面window.open()与子页面postMessage
                2、设置共域下的localStroge与window.onStroge监听
                   重复写入相同的值无法触发，会受到浏览器隐身模式等的影响
                3、设置共享cookie与不断轮询脏检查（setInterval)
        -->
        <!--
            浏览器架构：
                用户界面
                主进程
                内核
                    渲染引擎
                    JS引擎
                        js执行栈
                    事件触发线程
                        消息队列
                           宏任务
                           微任务
                    网络异步线程
                    定时器线程
        -->
        <!-- 
            重绘与回流
                当元素样式发生改变时，浏览器会触发更新、重新绘制元素，这个过程中包括两个类型的操作，即重绘和回流
                重绘（repaint）：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，由于只需要UI层面的重新绘制，
                                因此损耗较小
                回流（reflow）：当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。浏览器需要重新进行计算，
                               计算后需要重新进行页面布局，是较重的操作
                回流必定触发重绘，重绘不一定会触发回流，重绘开销较小，回流代价较高
         -->
         <!-- 
            内存泄漏：
                1、意外的全局变量：无法被回收 ----------this意外创建的全局变量，使用严格模式可避免
                2、被遗忘的定时器：未被正确关闭，导致所引用的外部变量无法被释放--------clearInterval()、clearTimeout() 来关闭
                3、事件监听：没有正确销毁
                4、闭包：会导致父级中的变量无法被释放---------不要滥用闭包
                5、dom引用：当dom元素被删除后，内存中的引用未被清空
          -->
         
	</body>
</html>