### 什么是虚拟DOM？
所谓虚拟DOM，就是用一个js对象来描述一个DOM节点，把组成一个DOM节点必要的东西，通过一个JS对象来表示出来，那么这个JS对象就被称为真实DOM节点的虚拟DOM节点

### 为什么要有虚拟DOM
，在vue中，是数据驱动视图的，数据发生变化，视图也要随之更新，在视图更新的时候难免要操作dom，然而操作真实的dom又非常消耗性能。  
* 解决方案：用js的计算性能来换取操作dom所消耗的性能

### 什么是以js的计算性能换取操作dom所消耗的性能
虽然我们无法避免操作dom，但是可以尽量少的去操作dom。不要盲目的去更新dom，而是通过对比数据变化前后的状态  
计算出视图中哪些地方需要更新，只更新需要更新的视图。从而实现尽量少的去操作dom。  
我们可以通过js去模拟出一个dom节点，称之为虚拟dom节点。当数据发生变化时，我们对比变化前后的虚拟dom节点，
通过`DOM-Diff`算法计算出需要更新的地方，然后再去更新需要更新的视图 

### vue中的虚拟dom
vue中存在一个`VNode`类，可以通过传入参数的不同实例化出不同类型的虚拟dom节点。包含的类型有：
* 注释节点
* 文本几点
* 组件节点
* 元素节点
* 函数式组件节点
* 克隆节点

`VNode`在Vue的整个虚拟dom过程中的作用：
我们在视图渲染前，把编写好的`template`模版先编译成`VNode`并缓存下来。当数据发生变化页面需要重新渲染时，我们把数据发生变化后生成的`VNode`与上一次缓存
下来的进行比较，比较差异，然后有差异的`VNode`对应的真实DOM节点就是需要重新渲染的节点。最后根据有差异的`VNode`创建出真实的DOM节点，再插入到视图中，
最后完成一次视图更新。`对比新旧两份VNode并找出差异的过程就是DOM-Diff过程`

### DOM-Diff过程
在vue中，`DOM-Diff`也被称为`patch`过程，其主要思想是：以生成的新的VNode为基准，改造OldVNode，让新旧VNode相同
`patch`的过程中主要做了三件事情：
* 创建节点：新的VNode中有，而旧的OldVNode中没有，则在旧OldVNode中创建
* 删除节点：新的VNode中没有，而旧的OldVNode中有，则在旧的OldVNode中删除
* 更新节点：新旧VNode中都有，则以新的VNode为基准，更新旧的OldVNode

1. 创建节点
vue中的VNode类可以描述6种类型的节点，实际上只有注释节点、文本节点、元素节点三种类型能真正被创建并插入到DOM中， 
源码中判断不同类型节点的方式：  
* 判断是否为元素节点，只需要判断该VNode中是否存在tag标签。如果是元素节点则调用`createElement`方法创建元素节点，如果还有子节点，则递归创建然后`insert`到当前元素节点中。最后将该元素节点插入到DOM中
* 判断是否为注释节点，只需要判断VNode中的`isComment`是否为true，然后通过`createComment`创建注释节点，最后插入到DOM中
* 如果以上两种都不是，则为文本节点,通过调用`createTextNode`方法创建文本节点，最后插入到DOM中

2. 删除节点
只需在要删除节点的父元素上调用`removeChild`方法即可删除

3. 更新节点
需要对以下三种情况进行判断：
* 如果VNode与OldVNode都为静态节点
直接跳过，不做任何操作

* VNode为文本节点
如果OldVnode也为文本节点，则判断两者的文本是否一样，不一样则把OldVNode的文本改成VNode的。  
如果OldVnode不是文本节点，则不管是什么节点都调用`setTextNode`把它改成文本节点，并把文本设置成和VNode一样

* VNode为元素节点
- VNode存在子节点
如果OldVnode也存在子节点，则递归对比更新子节点，如果不存在子节点，则OldVNode有可能是空节点或者文本节点，为空节点时，把VNode的子节点创建一份插入OldVNode中  
为文本节点，则清空文本，再把VNode的子节点创建一份插入OldVNode中 
- VNode不存在子节点
VNode不存在子节点，同时又不是文本节点，则VNode只能是空节点，不管OldVNode为什么节点，直接清空即可
> 注：在vue的`patchVnode`方法源码中，会判断节点的Key是否相等，所以循环时要设置不同的key

##### 更新子节点
当NewVNode与OldVNode都是元素节点并且都包含子节点时，那么这两个节点的VNode实例上的children属性就是包含的子节点数组。  
我们把NewVNode的子节点数组记为newChildren,OldVNode的子节点数组记为oldChildren,通过循环来进行对比，外层循环为newChildren节点，内层循环为oldChildren 
每循环外层一个newChildren节点就在内层oldChildren里面找有没有与之相同的子节点。  

此过程会出现四种情况：
此过程中，在oldChildren找到相同的节点时，我们把它处理完后标记为已处理

* 创建子节点
如果newChildren里面的某个子节点在oldChildren中找不到与之相同的子节点，说明该节点时此次需要新增的子节点，新建完此子节点后，需要把它插入到未处理节点的前面，而不是已处理节点的后面
* 删除子节点
如果newChildren循环完一次后，在oldChildren中仍然有未处理的子节点，说明这些子节点是被遗弃的，需要删除
* 移动子节点
如果在oldChildren中找到了与newChildren某个子节点相同的子节点，当所处的位置不一样，则需把oldChildren中该子节点移到与newChildren中一样的位置，移动的规则也是移到未处理节点的前面
* 更新子节点
如果在oldChildren中找到了与newChildren某个子节点相同的子节点，并且所处的位置也一样，那么就更新oldChildren中的该子节点，使之与newChildren的一样

##### 优化更新子节点
上述子节点更新的newChildren和oldChildren的双重循环中，当其中包含的子节点数量太庞大时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。  
vue的子节点更新优化策略中，为了避免此问题，选择了从子节点中四个特殊位置互相对比，分别是`新前与旧前、新后与旧后、新后与旧前、新前与旧后`

以上便是vue中的patch过程，也就是DOM-Diff算法所有内容